## 1.java中常用的工具类

```java
StringUtils.isAnyBlank
```

:dancer:常用于只要任意一个为空

````java
StringUtils.isNotBlank
````

:dancer:用于不为空

```java
   QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        if (StringUtils.isNotBlank(username)) {
            queryWrapper.like("user_name", username);
```

:man_dancing:用于查询匹配单个字段

## 2. 增删改查代码书写规范

- 增 save
- 删 remoceById
- 改 UpdateById
- 查
  -  list(全部数据）
  - 使用queryWrapper.like(单个数据)

##### 1.查询（返回列表）

```java
   @ApiOperation("管理员查询用户")
    @GetMapping("/search")
    public BaseResponse <List<User>> getUserById (String username, HttpServletRequest request){
        if (!userService.isAdmin(request)) {         //调用逻辑，判断是否为管理员登录
            throw new BusinessException(ErrorCode.NO_AUTH,"您不是管理员   ！");
        }
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        if (StringUtils.isNotBlank(username)) {
            queryWrapper.like("user_name", username);
        }
        List<User> userList = userService.list(queryWrapper);
        List<User> list = userList.stream().map(user -> userService.getSafetyUser(user)).collect(Collectors.toList());
        return ResultUtils.success(list);
    }
```

:man_dancing:常用于查询所有用户

## 3. 如何将数据进行脱敏处理，再返回

1. 服务类

```java
/**
 * 用户脱敏
 * @param originUser
 * @return User
 */
@Override public User getSafetyUser(User originUser) {
    if (originUser == null) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"脱敏数据为空！");
    }
    User safetyUser = new User();
    safetyUser.setId(originUser.getId());
    safetyUser.setUserName(originUser.getUserName());
    safetyUser.setUserAccount(originUser.getUserAccount());
    safetyUser.setAvatarUrl(originUser.getAvatarUrl());
    safetyUser.setGender(originUser.getGender());
    safetyUser.setPhone(originUser.getPhone());
    safetyUser.setEmail(originUser.getEmail());
    safetyUser.setPlanetCode(originUser.getPlanetCode());
    safetyUser.setUserRole(originUser.getUserRole());
    safetyUser.setUserStatus(originUser.getUserStatus());
    safetyUser.setCreateTime(originUser.getCreateTime());
    return safetyUser;
}
```

2. 实现类

```java
   /**
     *用户脱敏
     * @param originUser
     * @return
     */
    User getSafetyUser(User originUser);
```

3. controller业务类

```java
   //查询用户中返回的数据需要脱敏
List<User> userList = userService.list(queryWrapper);
List<User> list = userList.stream().map(user -> userService.getSafetyUser(user)).collect(Collectors.toList());
return ResultUtils.success(list);
```

## 4、Spring Boot  和Spring MVC 和Spring的区别

- Spring：是一个开源的Java应用程序框架，用于构建企业级Java应用程序。

- Spring MVC：是Spring框架中的一个Web应用程序开发框架，用于构建Web应用程序，实现了MVC（模型-视图-控制器）模式

- Spring Boot：是基于Spring框架的快速应用程序开发框架，旨在简化和加速Spring应用程序的创建和配置过程。

  **简而言之，Spring是整个框架，提供了丰富的功能和特性。Spring MVC是Spring框架中的一部分，专注于构建Web应用程序。Spring Boot是Spring框架的扩展，旨在简化和加速应用程序的开发过程。使用Spring Boot可以更快地启动和开发Spring应用程序，而Spring MVC是用于处理Web请求的一种方式。**
  
  


## 5.后端项目经典分层架构介绍

#### 分层架构

**表示层** 通常是指让用户交互和查看信息的前端界面，比如用户点击按钮后能够发送一个请求，也可以叫用户层、界面层等。
发送请求后，会经过 接入层 ，比如 Nginx 网关、或者其他中间件，对请求做一个预处理或转发，比如实现负载均衡。这一层不是必须存在的，通常更适用于中大型项目，前端也可以直接请求后端。

接入层会将请求转发到 **控制层**（Controller），负责接受请求、调用**业务逻辑层**（Service）的代码实现功能、然后响应结果。控制层一般不建议写复杂的业务逻辑，尽量保持精简。

接下来是 **业务逻辑层**（Service），负责处理复杂的业务逻辑，比如对请求数据进行校验、处理、调用数据访问层以将结果存到数据库中等，也是我们做系统时主要开发编码的部分。

通用**业务层**（Manager、Module）是一种特殊的业务逻辑层，主要的作用是抽取了一些需要被多个业务调用的公共代码，比如上传文件到对象存储、鉴权等，从而实现复用。

**数据访问层**（Dao / Mapper）负责操作底层的数据源，比如对数据库、文件、缓存等进行增删改查。

最后是 **系统资源层** ，也可以叫基础设施层，包括各种基础服务、系统环境等，比如数据库、消息队列、Redis、文件存储、Linux 系统、Docker 等。复杂的基础设施可能还包括 K8S 容器资源编排、资源调度平台等。

#### **示例项目结构**

基于分层架构，我们可以将项目按照特定的目录名（包名）来组织代码，比如：

- controller：控制层

- service：业务逻辑层

- mapper：数据访问层

- model：数据模型

还可以按照业务或文件的类型来划分目录，比如：

- constant：常量
- annotation：注解类
- common：公共类
- config：配置类
- job：任务
- exception：异常处理相关
- utils：工具类

#### **其他知识**

1）计算机网络也是采用了经典的分层架构，OSI 七层参考模型中，把计算机网络自底向上分为了物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。每个层只处理特定的功能，比如数据传输、数据的路由；层与层之间通过接口（或者叫协议）进行通信。

2）需要注意的是，我们常用的后端开发框架 Spring MVC 是基于 MVC（Model-View-Controller）设计模式构建的，而不能算是传统的分层架构。而且一般现在的项目中只使用 Spring MVC 作为整个项目的控制层，不过大多数用了 Spring MVC 框架的项目基本都使用了分层架构。

## 6、测试接口，配置swagger文档

根据官方文档选择适配自己的SpringBoot2.0或者3.0版本

> 官方链接:https://doc.xiaominfo.com/

Knife4j 的用法很简单，按照官方文档的指引，首先根据自己项目的 Spring Boot 版本引入对应的依赖，比如 Spring Boot 2.x 推荐使用以下 Maven 配置：

```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-openapi2-spring-boot-starter</artifactId>
    <version>4.3.0</version>
</dependency>
```

然后在 Spring Boot 的配置文件 application.yml 中添加 Knife4j 相关配置，比如：

```yaml
knife4j:
  enable: true
  openapi:
   	title: Knife4j 文档
```

 Knife4j 的文档地址（一般是项目地址 + /doc.html），即可查看自动根据 Controller 接口代码而生成的接口文档。

 Knife4j 的底层也是依赖 Swagger 的，所以你还可以使用 Swagger 注解来自定义接口的信息。
比如下列代码，就使用了 Swagger 的 @Api 和 @ApiOperation 注解给接口添加名称和描述信息：

```java
@RestController
@RequestMapping("/api/posts")
@Api(tags = "帖子管理")
public class PostController {

    @PostMapping
    @ApiOperation(value = "创建帖子", notes = "用于创建新的帖子")
    public ResponseEntity<String> createPost(@RequestBody PostRequest postRequest) {
        // 在这里实现创建帖子的逻辑
        return ResponseEntity.ok("帖子创建成功");
    }
}
```

## 7、MultipartHttpServletRequest的作用：

方便地处理带有文件上传的多部分请求。通过该接口，我们可以获取上传的文件、访问文件的元数据以及执行文件上传相关的操作。


```java
@PostMapping("/upload")
public String handleFileUpload(MultipartHttpServletRequest request) {
    MultipartFile file = request.getFile("file"); // 获取上传的文件

    if (file != null) {
        try {
            // 执行文件处理操作，如保存到磁盘、处理文件内容等
            file.transferTo(new File("/path/to/save/" + file.getOriginalFilename()));
            return "File uploaded successfully!";
        } catch (IOException e) {
            return "Failed to upload file.";
        }
    }
    
    return "No file uploaded.";
}
```


## 
